import { useEffect, useRef, useCallback } from "react";
import SockJS from "sockjs-client";
import Stomp from "stompjs";
import { isAuthenticated } from "../../utils/authGuard";

type ChatMessage = {
  chatMessageId: number;
  chatRoomId: number;
  senderId: number;
  content: string;
  sentAt: string;
  isRead: boolean;
};

export function useChatSocket(
  roomId: number,
  onMessage: (msg: ChatMessage) => void
) {
  const clientRef = useRef<Stomp.Client | null>(null);
  const isConnectedRef = useRef(false);
  const currentRoomIdRef = useRef<number | null>(null);
  const subscriptionRef = useRef<Stomp.Subscription | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;
  const reconnectDelay = 3000;
  const pendingMessages = useRef<string[]>([]);
  const connectionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const heartbeatIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const isMountedRef = useRef(true);
  const initRef = useRef(false);

  useEffect(() => {
    isMountedRef.current = true;
    if (!initRef.current) {
      initRef.current = true;
      console.log('üîÑ useChatSocket Ï≤´ Ï¥àÍ∏∞Ìôî');
    } else {
      console.log('üîÑ useChatSocket Ïû¨Ï¥àÍ∏∞Ìôî (StrictMode)');
    }
    
    // Î£∏ IDÍ∞Ä Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ÏóêÎßå Ï≤òÎ¶¨
    if (currentRoomIdRef.current !== roomId) {
      console.log(`Room changed from ${currentRoomIdRef.current} to ${roomId}`);

      // Í∏∞Ï°¥ Íµ¨ÎèÖ Ìï¥Ï†ú
      if (subscriptionRef.current) {
        console.log(`Unsubscribing from room ${currentRoomIdRef.current}`);
        subscriptionRef.current.unsubscribe();
        subscriptionRef.current = null;
      }

      currentRoomIdRef.current = roomId;
    } else if (subscriptionRef.current) {
      return () => {};
    }

    // ÎπÑÎèôÍ∏∞ Ïù∏Ï¶ù Ï≤¥ÌÅ¨ Î∞è Ïó∞Í≤∞
    const initializeConnection = async () => {
      const authenticated = isAuthenticated();
      if (!authenticated) {
        console.log("User not authenticated, skipping WebSocket connection");
        return;
      }

      // WebSocket Ïó∞Í≤∞Ïù¥ ÏóÜÏúºÎ©¥ ÏÉàÎ°ú ÏÉùÏÑ±
      if (!isConnectedRef.current || !clientRef.current?.connected) {
        console.log(`Opening WebSocket for room ${roomId}...`);
        isConnectedRef.current = true;

        const backendUrl = import.meta.env.VITE_BACKEND_BASE_URL || window.location.origin;
        const sockjsUrl = window.location.hostname === "localhost"
          ? `${backendUrl}/ws/chat-sockjs`
          : `${window.location.protocol}//${window.location.host}/ws/chat-sockjs`;
        
        console.log(`SockJS connecting to: ${sockjsUrl}`);
        
        const sock = new SockJS(sockjsUrl, null, {
          transports: ['websocket', 'xhr-streaming', 'xhr-polling']
        });
        const stomp = Stomp.over(sock);

        stomp.heartbeat.outgoing = 20000;
        stomp.heartbeat.incoming = 20000;
        stomp.debug = () => {};
        
        if (connectionTimeoutRef.current) {
          clearTimeout(connectionTimeoutRef.current);
        }
        connectionTimeoutRef.current = setTimeout(() => {
          if (!stomp.connected && isMountedRef.current) {
            console.warn('WebSocket Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ (10Ï¥à)');
            if (stomp.ws) {
              stomp.ws.close();
            }
          }
        }, 10000);
        clientRef.current = stomp;

        const connectHeaders: any = {};

        stomp.connect(
          connectHeaders,
          () => {
            if (!isMountedRef.current) return;
            
            console.log(`Connected to WebSocket for room ${roomId}`);
            reconnectAttempts.current = 0;
            isConnectedRef.current = true;
            
            if (connectionTimeoutRef.current) {
              clearTimeout(connectionTimeoutRef.current);
              connectionTimeoutRef.current = null;
            }
            
            if (heartbeatIntervalRef.current) {
              clearInterval(heartbeatIntervalRef.current);
            }
            heartbeatIntervalRef.current = setInterval(() => {
              if (stomp && stomp.connected) {
                try {
                  stomp.send('/app/ping', {}, '');
                } catch (error) {
                  console.warn('ÌïòÌä∏ÎπÑÌä∏ ping Ïã§Ìå®:', error);
                }
              }
            }, 30000);

            if (!subscriptionRef.current) {
              subscriptionRef.current = stomp.subscribe(
                `/topic/chat.${roomId}`,
                (message) => {
                  try {
                    const parsedMessage = JSON.parse(message.body);
                    console.log(
                      "Î©îÏãúÏßÄ ÏàòÏã†:",
                      parsedMessage.content,
                      "from senderId:",
                      parsedMessage.senderId,
                      "roomId:",
                      parsedMessage.chatRoomId
                    );
                    onMessage(parsedMessage);
                  } catch (error) {
                    console.error("Î©îÏãúÏßÄ ÌååÏã± Ïã§Ìå®:", error, message.body);
                  }
                }
              );
              console.log("Subscribed to topic:", `/topic/chat.${roomId}`);
            }

            const pending = [...pendingMessages.current];
            pendingMessages.current = [];
            pending.forEach(content => {
              console.log("ÎåÄÍ∏∞ Ï§ëÏù¥Îçò Î©îÏãúÏßÄ Ï†ÑÏÜ°:", content);
              sendMessageInternal(content, stomp);
            });
          },
          (error) => {
            if (!isMountedRef.current) return;
            
            console.error("WebSocket connection failed:", error);
            isConnectedRef.current = false;
            
            if (connectionTimeoutRef.current) {
              clearTimeout(connectionTimeoutRef.current);
              connectionTimeoutRef.current = null;
            }
            
            if (heartbeatIntervalRef.current) {
              clearInterval(heartbeatIntervalRef.current);
              heartbeatIntervalRef.current = null;
            }

            const isAuthError = error && (
              error.toString().includes('401') || 
              error.toString().includes('403') ||
              error.toString().includes('Unauthorized') ||
              error.toString().includes('Authentication')
            );

            if (isAuthError) {
              console.warn("WebSocket Ïù∏Ï¶ù Ïã§Ìå®: Ïû¨Ïó∞Í≤∞ Ï§ëÎã®");
              return;
            }

            if (reconnectAttempts.current < maxReconnectAttempts) {
              reconnectAttempts.current++;
              console.log(
                `WebSocket Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ${reconnectAttempts.current}/${maxReconnectAttempts} (${reconnectDelay}ms ÌõÑ)`
              );

              setTimeout(async () => {
                const stillAuthenticated = isAuthenticated();
                if (stillAuthenticated && isMountedRef.current) {
                  console.log(`Ïã§Ï†ú Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ${reconnectAttempts.current}/${maxReconnectAttempts}`);
                  isConnectedRef.current = false;
                  
                  if (clientRef.current) {
                    try {
                      if (clientRef.current.connected) {
                        clientRef.current.disconnect(() => {
                          console.log('Í∏∞Ï°¥ Ïó∞Í≤∞ Ï†ïÎ¶¨ ÏôÑÎ£å, Ïû¨Ïó∞Í≤∞ ÏãúÏûë');
                        });
                      }
                    } catch (e) {
                      console.warn('Í∏∞Ï°¥ Ïó∞Í≤∞ Ï†ïÎ¶¨ Ï§ë Ïò§Î•ò:', e);
                    }
                    clientRef.current = null;
                  }
                  
                  subscriptionRef.current = null;
                  initializeConnection();
                }
              }, reconnectDelay);
            } else {
              console.error("WebSocket ÏµúÎåÄ Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ÌöüÏàò Ï¥àÍ≥º");
            }
          }
        );
      } else if (clientRef.current?.connected && subscriptionRef.current) {
        console.log(`Already subscribed to room ${roomId}`);
      } else if (clientRef.current?.connected && !subscriptionRef.current) {
        console.log(`Subscribing to room ${roomId} on existing connection`);
        subscriptionRef.current = clientRef.current.subscribe(
          `/topic/chat.${roomId}`,
          (message) => {
            try {
              const parsedMessage = JSON.parse(message.body);
              console.log(
                "Î©îÏãúÏßÄ ÏàòÏã†:",
                parsedMessage.content,
                "from senderId:",
                parsedMessage.senderId,
                "roomId:",
                parsedMessage.chatRoomId
              );
              onMessage(parsedMessage);
            } catch (error) {
              console.error("Î©îÏãúÏßÄ ÌååÏã± Ïã§Ìå®:", error, message.body);
            }
          }
        );
        console.log("Subscribed to topic:", `/topic/chat.${roomId}`);
      }
    };

    initializeConnection();

    return () => {
      if (subscriptionRef.current) {
        console.log(`Unsubscribing from room ${roomId}`);
        try {
          subscriptionRef.current.unsubscribe();
        } catch (error) {
          console.warn('Íµ¨ÎèÖ Ìï¥Ï†ú Ï§ë Ïò§Î•ò:', error);
        }
        subscriptionRef.current = null;
      }
      
      if (connectionTimeoutRef.current) {
        clearTimeout(connectionTimeoutRef.current);
        connectionTimeoutRef.current = null;
      }
      
      if (heartbeatIntervalRef.current) {
        clearInterval(heartbeatIntervalRef.current);
        heartbeatIntervalRef.current = null;
      }
    };
  }, [roomId, onMessage]);
  
  useEffect(() => {
    return () => {
      console.log('useChatSocket cleanup ÏãúÏûë');
      
      initRef.current = false;
      
      if (connectionTimeoutRef.current) {
        clearTimeout(connectionTimeoutRef.current);
        connectionTimeoutRef.current = null;
      }
      
      if (heartbeatIntervalRef.current) {
        clearInterval(heartbeatIntervalRef.current);
        heartbeatIntervalRef.current = null;
      }
      
      if (subscriptionRef.current) {
        try {
          subscriptionRef.current.unsubscribe();
          subscriptionRef.current = null;
        } catch (error) {
          console.warn('Íµ¨ÎèÖ Ìï¥Ï†ú Ï§ë Ïò§Î•ò:', error);
        }
      }
      
      setTimeout(() => {
        if (initRef.current) {
          console.log('üõë Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä Ïû¨Ï¥àÍ∏∞ÌôîÎêòÏñ¥ Ï†ïÎ¶¨ Í±¥ÎÑàÎúÄ');
          return;
        }
        
        console.log('üßπ useChatSocket ÏµúÏ¢Ö Ï†ïÎ¶¨ ÏãúÏûë');
        isMountedRef.current = false;
        
        if (clientRef.current) {
          try {
            if (clientRef.current.connected) {
              clientRef.current.disconnect(() => {
                console.log('Ï±ÑÌåÖ WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å');
              });
            }
          } catch (error) {
            console.warn('WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å Ï§ë Ïò§Î•ò:', error);
          }
          clientRef.current = null;
        }
        
        isConnectedRef.current = false;
        currentRoomIdRef.current = null;
        reconnectAttempts.current = 0;
        pendingMessages.current = [];
      }, 100);
    };
  }, []);

  const sendMessageInternal = useCallback(async (content: string, stomp: Stomp.Client) => {
    try {
      let userId = null;
      try {
        const response = await fetch('/api/events/user/role', {
          credentials: 'include',
          headers: { 'X-Silent-Auth': 'true' }
        });
        if (response.ok) {
          const userData = await response.json();
          userId = userData.userId;
        }
      } catch (error) {
        console.error("ÏÇ¨Ïö©Ïûê ID Ï°∞Ìöå Ïã§Ìå®:", error);
      }

      const messagePayload = {
        chatRoomId: roomId,
        content: content.trim(),
        senderId: userId || 1,
      };

      console.log("Î©îÏãúÏßÄ Ï†ÑÏÜ°:", content.trim(), "from userId:", userId);

      stomp.send(
        "/app/chat.sendMessage",
        {},
        JSON.stringify(messagePayload)
      );
    } catch (error) {
      console.error("Failed to send message:", error);
    }
  }, [roomId]);

  const send = useCallback(
    (content: string) => {
      if (!content.trim()) {
        console.warn("Cannot send empty message");
        return;
      }

      const stomp = clientRef.current;

      if (!isMountedRef.current && initRef.current) {
        console.log('‚ö†Ô∏è isMountedRefÍ∞Ä falseÏù¥ÏßÄÎßå Ïª¥Ìè¨ÎÑåÌä∏Îäî ÌôúÏÑ± ÏÉÅÌÉú - Î≥µÍµ¨ ÏãúÎèÑ');
        isMountedRef.current = true;
      }
      
      console.log('üì® Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏãúÎèÑ:', {
        content: content.trim(),
        isMounted: isMountedRef.current,
        hasClient: !!stomp,
        isConnected: stomp?.connected,
        hasSubscription: !!subscriptionRef.current,
        initRef: initRef.current
      });

      if (stomp && stomp.connected && subscriptionRef.current) {
        console.log("‚úÖ WebSocket Ïó∞Í≤∞ ÏÉÅÌÉú, Ï¶âÏãú Ï†ÑÏÜ°:", content.trim());
        sendMessageInternal(content.trim(), stomp);
      } else if (stomp && stomp.connected) {
        console.warn("‚ö†Ô∏è WebSocket Ïó∞Í≤∞Îê®, ÌïòÏßÄÎßå Íµ¨ÎèÖ ÏïàÎê®");
        sendMessageInternal(content.trim(), stomp);
      } else {
        if (pendingMessages.current.length < 10) {
          console.log("‚è≥ WebSocket Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë, Î©îÏãúÏßÄ ÌÅêÏóê Ï∂îÍ∞Ä:", content.trim());
          pendingMessages.current.push(content.trim());
        } else {
          console.warn('‚ùå ÎåÄÍ∏∞ Î©îÏãúÏßÄ ÌÅê Ï¥àÍ≥º, Ï†ÑÏÜ° Ïã§Ìå®:', content.trim());
        }
      }
    },
    [sendMessageInternal]
  );

  return { send };
}