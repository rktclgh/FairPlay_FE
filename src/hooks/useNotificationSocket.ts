import { useEffect, useRef, useCallback, useState } from "react";
import SockJS from "sockjs-client";
import Stomp from "stompjs";
import { useAuth } from "../context/AuthContext";

export type Notification = {
  notificationId: number;
  typeCode: string;
  methodCode: string;
  title: string;
  message: string;
  url?: string;
  isRead: boolean;
  createdAt: string;
};

export function useNotificationSocket() {
  const { isAuthenticated } = useAuth();
  const clientRef = useRef<Stomp.Client | null>(null);
  const isConnectedRef = useRef(false);
  const subscriptionRef = useRef<Stomp.Subscription | null>(null);
  const broadcastSubscriptionRef = useRef<Stomp.Subscription | null>(null);
  const readSubscriptionRef = useRef<Stomp.Subscription | null>(null);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;
  const reconnectDelay = 3000;

  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);

  const updateUnreadCount = useCallback((notifications: Notification[]) => {
    const count = notifications.filter(n => !n.isRead).length;
    setUnreadCount(count);
  }, []);

  const onNewNotification = useCallback((notification: Notification) => {
    console.log("üì® onNewNotification Ìò∏Ï∂úÎê®:", notification);
    setNotifications(prev => {
      console.log("üì® Ïù¥Ï†Ñ ÏïåÎ¶º Î™©Î°ù:", prev.length);
      // Ï§ëÎ≥µ Î∞©ÏßÄ: Í∞ôÏùÄ IDÏùò ÏïåÎ¶ºÏù¥ Ïù¥ÎØ∏ ÏûàÎäîÏßÄ ÌôïÏù∏
      const exists = prev.some(n => n.notificationId === notification.notificationId);
      if (exists) {
        console.log("üì® Ï§ëÎ≥µ ÏïåÎ¶º Î¨¥Ïãú:", notification.notificationId);
        return prev;
      }
      const updated = [notification, ...prev];
      console.log("üì® ÏÉà ÏïåÎ¶º Ï∂îÍ∞Ä ÌõÑ Î™©Î°ù:", updated.length);
      updateUnreadCount(updated);
      return updated;
    });
    
    // Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶º ÌëúÏãú (iOS Safari Ìò∏Ìôò)
    if (typeof Notification !== 'undefined' && Notification.permission === "granted") {
      new Notification(notification.title, {
        body: notification.message,
        icon: "/favicon.ico"
      });
    }
  }, [updateUnreadCount]);

  // ================================= Ï§ëÎ≥µ ÏùΩÏùå Ï≤òÎ¶¨ Î∞©ÏßÄ =================================
  const onNotificationRead = useCallback((notificationId: number) => {
    console.log('üì© Î∞±ÏóîÎìúÏóêÏÑú ÏùΩÏùå Ï≤òÎ¶¨ ÏùëÎãµ:', notificationId);
    
    setNotifications(prev => {
      const notification = prev.find(n => n.notificationId === notificationId);
      if (!notification) {
        console.log('üì© Ìï¥Îãπ ÏïåÎ¶º ÏóÜÏùå:', notificationId);
        return prev;
      }
      
      if (notification.isRead) {
        console.log('üì© Ïù¥ÎØ∏ ÏùΩÏùå Ï≤òÎ¶¨Îêú ÏïåÎ¶º (Ïä§ÌÇµ):', notificationId);
        return prev; // Ïù¥ÎØ∏ ÏùΩÏùå Ï≤òÎ¶¨Îêú Í≤ΩÏö∞ ÏÉÅÌÉú Î≥ÄÍ≤Ω ÏóÜÏùå
      }
      
      console.log('üì© Î∞±ÏóîÎìú ÏùëÎãµÏúºÎ°ú ÏùΩÏùå ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏:', notificationId);
      const updated = prev.map(n => 
        n.notificationId === notificationId 
          ? { ...n, isRead: true }
          : n
      );
      updateUnreadCount(updated);
      return updated;
    });
  }, [updateUnreadCount]);
  // ===============================================================================

  const onNotificationDeleted = useCallback((notificationId: number) => {
    console.log("üóëÔ∏è ÏïåÎ¶º ÏÇ≠Ï†ú ÏôÑÎ£å:", notificationId);
    setNotifications(prev => {
      const updated = prev.filter(n => n.notificationId !== notificationId);
      updateUnreadCount(updated);
      return updated;
    });
  }, [updateUnreadCount]);

  const connect = useCallback(() => {
    if (isConnectedRef.current || !isAuthenticated) return;

    console.log("Connecting to notification WebSocket...");
    isConnectedRef.current = true;
    
    // HTTP-only Ïø†ÌÇ§ ÏÇ¨Ïö©ÏúºÎ°ú ÌÜ†ÌÅ∞ ÌååÎùºÎØ∏ÌÑ∞ Î∂àÌïÑÏöî (Ïø†ÌÇ§Í∞Ä ÏûêÎèô Ï†ÑÏÜ°Îê®)
    const sockjsUrl = window.location.hostname === "localhost"
      ? `${import.meta.env.VITE_BACKEND_BASE_URL}/ws/notifications-sockjs`
      : `${window.location.protocol}//${window.location.host}/ws/notifications-sockjs`;
    
    console.log(`SockJS connecting to: ${sockjsUrl} (using HTTP-only cookies)`);
    
    const sock = new SockJS(sockjsUrl);
    const stomp = Stomp.over(sock);

    stomp.heartbeat.outgoing = 25000;
    stomp.heartbeat.incoming = 25000;
    stomp.debug = () => {};
    clientRef.current = stomp;

    // HTTP-only Ïø†ÌÇ§ ÏÇ¨Ïö©ÏúºÎ°ú Î≥ÑÎèÑ Ïù∏Ï¶ù Ìó§Îçî Î∂àÌïÑÏöî
    const connectHeaders: any = {};

    stomp.connect(
      connectHeaders,
      () => {
        console.log("Connected to notification WebSocket");
        reconnectAttempts.current = 0;

        console.log("üîå ÏõπÏÜåÏºì Ïó∞Í≤∞ ÏÑ±Í≥µ, Íµ¨ÎèÖ ÏãúÏûë");
        
        // Í∏∞Ï°¥ ÏïåÎ¶º Î™©Î°ù ÏßÅÏ†ë ÏöîÏ≤≠ (REST API Ìò∏Ï∂ú) - HTTP-only Ïø†ÌÇ§ ÏÇ¨Ïö©
        const fetchExistingNotifications = async () => {
          try {
            if (!isAuthenticated) return;
            
            const response = await fetch(`${import.meta.env.VITE_BACKEND_BASE_URL}/api/notifications`, {
              credentials: 'include', // HTTP-only Ïø†ÌÇ§ Ìè¨Ìï®
              headers: {
                'Content-Type': 'application/json'
              }
            });
            
            if (response.ok) {
              const existingNotifications = await response.json();
              console.log("üîÑ REST APIÎ°ú Í∏∞Ï°¥ ÏïåÎ¶º Î™©Î°ù Î°úÎìú:", existingNotifications.length);
              console.log("üîÑ Í∏∞Ï°¥ ÏïåÎ¶º Îç∞Ïù¥ÌÑ∞:", existingNotifications);
              setNotifications(existingNotifications);
              updateUnreadCount(existingNotifications);
            } else {
              console.log("üìã Í∏∞Ï°¥ ÏïåÎ¶º ÏóÜÏùå ÎòêÎäî Î°úÎìú Ïã§Ìå®");
              setNotifications([]);
              updateUnreadCount([]);
            }
          } catch (error) {
            console.error("Í∏∞Ï°¥ ÏïåÎ¶º Î°úÎìú Ïã§Ìå®:", error);
            setNotifications([]);
            updateUnreadCount([]);
          }
        };
        
        // Í∏∞Ï°¥ ÏïåÎ¶º Î°úÎìú
        fetchExistingNotifications();

        // Ïû†Ïãú ÌõÑ Í∞úÏù∏ ÏïåÎ¶º Íµ¨ÎèÖ (Í∏∞Ï°¥ ÏïåÎ¶º Î°úÎìú ÌõÑ)
        setTimeout(() => {
          // Í∞úÏù∏ ÏïåÎ¶º Íµ¨ÎèÖ
          subscriptionRef.current = stomp.subscribe(
            "/user/topic/notifications",
            (message) => {
              try {
                const notification = JSON.parse(message.body);
                console.log("üì® ÏÉà Í∞úÏù∏ ÏïåÎ¶º ÏàòÏã†:", notification);
                onNewNotification(notification);
              } catch (error) {
                console.error("ÏïåÎ¶º ÌååÏã± Ïã§Ìå®:", error);
              }
            }
          );

          // Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ ÏïåÎ¶º Íµ¨ÎèÖ
          broadcastSubscriptionRef.current = stomp.subscribe(
            "/topic/notifications/broadcast",
            (message) => {
              try {
                const notification = JSON.parse(message.body);
                console.log("üì¢ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ ÏïåÎ¶º ÏàòÏã†:", notification);
                onNewNotification(notification);
              } catch (error) {
                console.error("Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ ÏïåÎ¶º ÌååÏã± Ïã§Ìå®:", error);
              }
            }
          );

          // ÏùΩÏùå Ï≤òÎ¶¨ ÏïåÎ¶º Íµ¨ÎèÖ
          readSubscriptionRef.current = stomp.subscribe(
            "/user/topic/notifications/read",
            (message) => {
              try {
                const notificationId = JSON.parse(message.body);
                console.log("‚úÖ ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨:", notificationId);
                onNotificationRead(notificationId);
              } catch (error) {
                console.error("ÏùΩÏùå Ï≤òÎ¶¨ ÌååÏã± Ïã§Ìå®:", error);
              }
            }
          );

          // ÏÇ≠Ï†ú Ï≤òÎ¶¨ ÏïåÎ¶º Íµ¨ÎèÖ
          const deleteSubscriptionRef = stomp.subscribe(
            "/user/topic/notifications/deleted",
            (message) => {
              try {
                const notificationId = JSON.parse(message.body);
                console.log("üóëÔ∏è ÏïåÎ¶º ÏÇ≠Ï†ú Ï≤òÎ¶¨:", notificationId);
                onNotificationDeleted(notificationId);
              } catch (error) {
                console.error("ÏÇ≠Ï†ú Ï≤òÎ¶¨ ÌååÏã± Ïã§Ìå®:", error);
              }
            }
          );
          
          console.log("üîî Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Íµ¨ÎèÖ ÏôÑÎ£å");
        }, 100);
      },
      (error) => {
        console.error("Notification WebSocket connection failed:", error);
        isConnectedRef.current = false;

        if (reconnectAttempts.current < maxReconnectAttempts) {
          reconnectAttempts.current++;
          console.log(
            `ÏïåÎ¶º ÏõπÏÜåÏºì Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ ${reconnectAttempts.current}/${maxReconnectAttempts}`
          );
          setTimeout(() => {
            isConnectedRef.current = false;
            connect();
          }, reconnectDelay);
        }
      }
    );
  }, [onNewNotification, onNotificationRead, onNotificationDeleted, updateUnreadCount]);

  const disconnect = useCallback(() => {
    if (subscriptionRef.current) {
      subscriptionRef.current.unsubscribe();
      subscriptionRef.current = null;
    }
    if (broadcastSubscriptionRef.current) {
      broadcastSubscriptionRef.current.unsubscribe();
      broadcastSubscriptionRef.current = null;
    }
    if (readSubscriptionRef.current) {
      readSubscriptionRef.current.unsubscribe();
      readSubscriptionRef.current = null;
    }
    if (clientRef.current?.connected) {
      clientRef.current.disconnect(() => {
        console.log("Notification WebSocket disconnected");
      });
    }
    isConnectedRef.current = false;
  }, []);

  // ================================= ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏Î°ú Ï¶âÏãú UI Î∞òÏòÅ =================================
  const markAsRead = useCallback((notificationId: number) => {
    console.log('üìñ ÏïåÎ¶º ÏùΩÏùå Ï≤òÎ¶¨ ÏãúÏûë:', notificationId);
    
    // Ïù¥ÎØ∏ ÏùΩÏùÄ ÏïåÎ¶ºÏù¥Î©¥ Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
    const notification = notifications.find(n => n.notificationId === notificationId);
    if (!notification || notification.isRead) {
      console.log('üìñ Ïù¥ÎØ∏ ÏùΩÏùÄ ÏïåÎ¶ºÏù¥Í±∞ÎÇò Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå:', notificationId);
      return;
    }

    // 1. Ï¶âÏãú UI ÏóÖÎç∞Ïù¥Ìä∏ (ÎÇôÍ¥ÄÏ†Å ÏóÖÎç∞Ïù¥Ìä∏)
    setNotifications(prev => {
      const updated = prev.map(n => 
        n.notificationId === notificationId 
          ? { ...n, isRead: true }
          : n
      );
      updateUnreadCount(updated);
      console.log('üìñ Ï¶âÏãú UI ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å:', notificationId);
      return updated;
    });

    // 2. Î∞±ÏóîÎìú ÎèôÍ∏∞Ìôî
    const stomp = clientRef.current;
    if (stomp && stomp.connected) {
      console.log('üìñ WebSocketÏúºÎ°ú Î∞±ÏóîÎìú ÎèôÍ∏∞Ìôî:', notificationId);
      stomp.send("/app/notifications/markRead", {}, JSON.stringify(notificationId));
    } else {
      console.warn('üìñ WebSocket Ïó∞Í≤∞ ÏóÜÏùå, ÏùΩÏùå Ï≤òÎ¶¨ Ïä§ÌÇµ:', notificationId);
      // WebSocketÏù¥ ÎÅäÏñ¥ÏßÑ Í≤ΩÏö∞ÏóêÎèÑ UIÎäî Ïù¥ÎØ∏ ÏóÖÎç∞Ïù¥Ìä∏ ÎêòÏñ¥ ÏÇ¨Ïö©Ïûê Í≤ΩÌóò Ìñ•ÏÉÅ
    }
  }, [notifications, updateUnreadCount]);
  // ===============================================================================================

  const deleteNotification = useCallback((notificationId: number) => {
    const stomp = clientRef.current;
    if (!stomp || !stomp.connected) {
      console.warn("WebSocket Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå - ÏÇ≠Ï†ú Î∂àÍ∞Ä");
      return false;
    }

    // 1. Ï¶âÏãú UIÏóêÏÑú Ï†úÍ±∞ (ÏïÑÏù¥Ìè∞ Ïä§ÌÉÄÏùº)
    console.log("üóëÔ∏è Ï¶âÏãú Î°úÏª¨ÏóêÏÑú ÏïåÎ¶º Ï†úÍ±∞:", notificationId);
    setNotifications(prev => {
      const updated = prev.filter(n => n.notificationId !== notificationId);
      updateUnreadCount(updated);
      return updated;
    });

    // 2. Î∞±ÏóîÎìúÎ°ú soft delete ÏöîÏ≤≠ - HTTP-only Ïø†ÌÇ§ ÏûêÎèô ÏÇ¨Ïö©
    console.log("üóëÔ∏è WebSocketÏúºÎ°ú ÏïåÎ¶º ÏÇ≠Ï†ú ÏöîÏ≤≠:", notificationId);
    stomp.send("/app/notifications/delete", {}, JSON.stringify(notificationId));
    return true;
  }, [updateUnreadCount]);

  // Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠ (iOS Safari Ìò∏Ìôò)
  useEffect(() => {
    if (typeof Notification !== 'undefined' && Notification.permission === "default") {
      Notification.requestPermission();
    }
  }, []);

  return {
    notifications,
    unreadCount,
    connect,
    disconnect,
    markAsRead,
    deleteNotification,
    isConnected: isConnectedRef.current
  };
}